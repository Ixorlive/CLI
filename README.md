# CLI

Авторы:

- Шакиров Игорь
- Чучин Дмитрий

# Краткое описание работы CLI

_Под фазой в описании подразумевается разделение на 2 фазы разработки — сначала без подстановок и пайпов, затем с ними.
Части описания, которые относятся ко второй фазе имеют соответсвующее пояснение._

Основной класс **Interpreter**, он запускает интерпретатор и ждет, пока пользователь введет команду.

(фаза II)
Затем входной поток передаётся **Preprocessor**, который при необходимости заменяет любые вхождения переменных,
обозначенных символом «$», соответствующими значениями.

Полученная обработанная строка передаётся **Lexer**, он разбивает ее на токены в виде односвязного списка и
предоставляет
их в качестве итератора с помощью команды NextToken() (итератором выступает сам лексер).

Полученный Lexer передается в качестве аргумента конструктора классу **Parser**, который проходится по токенам и
инициализирует список команд **Command** в виде массива. Поскольку команды в shell выполняются последовательно, соседние
элементы массива соединяются с помощью механизма Pipeline (на фазе II).

Полученный массив команд затем передается **Executor**, который исполняет команды.

Сами команды **CommandBase** принимают список аргументов, поток ввода и поток вывода. Executor гарантирует, что поток
вывода одной команды станет потоком ввода следующей команды. Сами команды используют как список аргументов, так и поток
ввода.

Результатом Executor является выходной поток и логическое значение, указывающее, следует ли выйти из интерпретатора.
Класс Interpreter получает этот результат и ожидает следующей команды, если команды выхода не было.

# Диаграмма классов

![Class Diagramm](./public/ClassDiagram.png)

### Interpreter

Приложение-интерпретатор ожидает ввода пользователем команды и выполняет четыре этапа обработки входной строки:
предварительная обработка, лексический анализ, разбор команд и выполнение команд. Если на любом из этих этапов возникает
ошибка, приложение уведомляет пользователя и ожидает новой команды.

### Preprocessor (фаза II)

Препроцессор обрабатывает строку посимвольно следующим образом:

* если очередной символ не $, ' или ", то он будет проигнорирован препроцессором;
* если очередной символ $, то:
    * препроцессор жадно попытается прочитать полное имя переменной, пока не встретит символ, которого не может быть в
      имени
      переменной ([подробнее про имена](https://www.gnu.org/software/bash/manual/html_node/Definitions.html#index-name))
      ;
    * вместо символа $ и имени переменной подставляется значение из **ContextProvider**;
* если очередной символ ', то пока не будет встречено ' препроцессор будет игнорировать символы " и $;
* если очередной символ ", то пока не будет встречено " препроцессор будет игнорировать символ '.

### Lexer

**Lexer** берет предварительно обработанную строку и представляет ее как односвязный список токенов. Токен — это
строковое
представление команды, аргумента команды или пайплайна. Например, "cat example.txt | wc" будет представлено
как ["cat", "example.txt", "|", "wc"]. После обработки лексер содержит указатель на первый токен.

### Parser

Синтаксический анализатор сначала считывает команду, создает объект CommandBase и инициализирует команду. Затем он
добавляет аргументы пока остались токены, результирующая команда помещается в одноэлементный массив.

(фаза II) Синтаксический анализатор сначала считывает команду, создает объект CommandBase и инициализирует команду.
Затем он
добавляет аргументы, пока не встретит пайплайн. После встречи с '|' или концом списка токенов, результирующая команда
добавляется в массив. Процесс повторяется, если остались токены.

### CommandFactory

Этот объект берет имя команды и сначала ищет внутреннюю команду.

* если команда найдена, она возвращает наследника CommandBase, соответствующего переданной команде;
* если команда не найдена, выполняется поиск внешней команды в текущей директории и
  в директориях из переменной окружения PATH, затем создается объект
  ExternalCommand (фактическое исполнение команды в ExternalCommand происходит с помощью отдельного процесса);
* если команда не найдена в PATH, то возвращается сообщение об ошибке.

### Executor

**Executor** получает на вход массив объектов **Command** (на фазе I это всегда массив из одного элемента).
Команда среди аргументов метода Execute получает на вход входной и выходной потоки, которые
связаны с stdin и stdout.

На фазе II команды будут запускаться последовательно одна
за другой. Каждая команда среди аргументов метода Execute получает на вход входной и выходной потоки.
Первой команде в качестве входного потока передается stdin, а последней команде в качестве выходного потока
передается stdout. Остальные входные и выходные потоки создаются отдельно
и передаются так, чтобы выходной поток текущей команды был тем же, что и входной поток следующей команды.

# Диаграмма последовательности

![Sequence diagram](./public/SequenceDiagram.png)

На данной диаграмме изображено время жизни каждого объекта и их взаимодействие в каждой итерации - ввода команды
пользователем.

# Тонкости

### Присваивание

Мы решили реализовать присваивание как команду. Однако она отличается от остальных тем, что в конструкторе принимает
ContextProvider для того, чтобы записывать туда значение переменной.

### Команда exit

exit также является командой, которая читает входной поток и игнорирует его, выводя пустую строку.
Однако требуется, чтобы Executor проверял - если всего команд 1 в массиве и это exit, то возвращал в Iterpreter сигнал о
завершении работы.

### CommandFactory и вызов внешних команд

Внешние команды также являются наследником Command. (пока под вопросом) Создаётся ExternalCommand, который принимают
Process(или его аналоги).

# Обработка ошибок

Чтобы обеспечить приемлемую обработку ошибок, мы решили выполнять все основные этапы внутри интерпретатора. Если на
каком-либо шаге возникают какие-либо проблемы, программа выводит информацию об ошибке. Примеры включают:

- Некорректный ввод команды: синтаксический анализатор попросит CommandFactory создать команду, но если он не распознает
  команду, он выдаст исключение. Затем синтаксический анализатор перебросит исключение с сообщением «Неизвестная
  команда».
- Неверное количество аргументов - Парсинг пройдёт успешно и передаст команды Executor. При выполнении команды, **
  команда обязуется проверять корректность переданных аргументов** и выбрасывать исключение.
- (фаза II) (под вопросом) Запись вида "abc =45" - ["abc", "=45"] - ошибка неизвестная команда. "abc= 53"
  - ["abc=", "", "53"]
  неизвестная команда "53". Тут ещё надо подумать, как лучше представить присваивание как токен,
  мб ["=", "v_name", "v_value"]. Ошибка парсинга\лексера.

# Ответы на важные вопросы, кратко

### Как предствавляются команды и пайплайны?

Есть абстрактный класс **CommandBase**, который определяет виртуальный метод Execute(). Каждая команда должна
реализовать этот метод.

Пайплайн представлен как разделитель соседних элементов массива команд, который возвращает Parser.

### Как создаются команды?

С помощью объекта CommandFactory.

### Как они исполняются? Как взаимодействуют потоки в пайплайне?

Метод Execute() принимает аргументы, поток ввода и вывода. Следовательно, взаимодействие пайплайнов происходит за счёт
записи в поток вывода одной команды, который читается следующей командой.

### Кто и как выполняет разбор входной строки?

Preprocessor для подстановки, Lexer для разбора строки.

### Как представляются переменные окружения?

В переменных окружения процесса, где запущена программа, доступ к ним обеспечивается с помощью объекта ContextProvider.

### Что с многопоточностью?

Пока исполнение команд в pipe будет происходить последовательно, однако для реализации многопоточности
будет достаточно модифицировать то, как класс Executor, запускает команды. 